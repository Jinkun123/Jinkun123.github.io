<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue-9-perf-secrets</title>
      <link href="2021/09/28/vue-9-perf-secrets/"/>
      <url>2021/09/28/vue-9-perf-secrets/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>又是菜菜的我来了，所谓水群就是学习的宗旨，昨天我们伟大的群主大大推荐了一个非常好的项目，经过昨天到今天的研究百度，已经有了大概的了解，并以此感叹大佬真的好厉害。把一些好的知识要点记录，并加深印象。(大佬勿喷！)</code></p><p>这篇文章主要参考了 Vue.js 核心成员 Guillaume Chau 在 19 年美国的 Vue conf 分享的主题：9 Performance secrets revealed，分享中提到了九个 Vue.js 性能优化的技巧。</p><p>这个分享可谓是非常实用了，但是知道和关注的人似乎并不多，到目前为止，该项目也只有可怜的几百个 star。虽然距大佬的分享已经有两年时间，但是其中的优化技巧并没有过时，为了让更多的人了解并学习到其中的实用技巧，我决定对他的分享做二次加工，详细阐述其中的优化原理，并做一定程度的扩展和延伸。</p><p>建议你在学习这篇文章的时候可以拉取项目的源码，并且本地运行，查看优化前后的效果差异。</p><h3 id="接下来就是正文了"><a href="#接下来就是正文了" class="headerlink" title="接下来就是正文了"></a>接下来就是正文了</h3><h4 id="1-Functional-components"><a href="#1-Functional-components" class="headerlink" title="1. Functional components"></a>1. Functional components</h4><p>   第一个技巧，函数式组件，你可以查看这个在线示例</p><p>   优化前的组件代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;cell&quot;&gt;</span><br><span class="line">        &lt;div v-if&#x3D;&quot;value&quot; class&#x3D;&quot;on&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p v-else class&#x3D;&quot;off&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">      props: [&#39;value&#39;],</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>优化后的组件代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template functional&gt;</span><br><span class="line">   &lt;div class&#x3D;&quot;cell&quot;&gt;</span><br><span class="line">      &lt;div v-if&#x3D;&quot;props.value&quot; class&#x3D;&quot;on&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;p v-else class&#x3D;&quot;off&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt; </span><br></pre></td></tr></table></figure><p>然后我们在父组件各渲染优化前后的组件 800 个，并在每一帧内部通过修改数据来触发组件的更新，开启 Chrome 的 Performance 面板记录它们的性能，得到如下结果。</p><p>优化前：<br><img src="https://cdn.jsdelivr.net/gh/Jinkun123/blog_imgs/2020-01-12/FunctionalComponentsOff.png"></p><p>优化后：<br><img src="https://cdn.jsdelivr.net/gh/Jinkun123/blog_imgs/2020-01-12/FunctionalComponentsOn.png"></p><p>对比这两张图我们可以看到优化前执行 script 的时间要多于优化后的，而我们知道 JS 引擎是单线程的运行机制，JS 线程会阻塞 UI 线程，所以当脚本执行时间过长，就会阻塞渲染，导致页面卡顿。而优化后的 script 执行时间短，所以它的性能更好。</p><p>那么，为什么用函数式组件 JS 的执行时间就变短了呢？这要从函数式组件的实现原理说起了，你可以把它理解成一个函数，它可以根据你传递的上下文数据渲染生成一片 DOM。</p><p>函数式组件和普通的对象类型的组件不同，它不会被看作成一个真正的组件，我们知道在 patch 过程中，如果遇到一个节点是组件 vnode，会递归执行子组件的初始化过程；而函数式组件的 render 生成的是普通的 vnode，不会有递归子组件的过程，因此渲染开销会低很多。</p><p>因此，函数式组件也不会有状态，不会有响应式数据，生命周期钩子函数这些东西。你可以把它当成把普通组件模板中的一部分 DOM 剥离出来，通过函数的方式渲染出来，是一种在 DOM 层面的复用。</p><h4 id="2-Child-component-splitting"><a href="#2-Child-component-splitting" class="headerlink" title="2. Child component splitting"></a>2. Child component splitting</h4><p>第二个技巧，子组件拆分，你可以查看这个在线示例。</p><p>优化前的组件代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :style&#x3D;&quot;&#123; opacity: number &#x2F; 300 &#125;&quot;&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; heavy() &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&#39;number&#39;],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    heavy () &#123;</span><br><span class="line">      const n &#x3D; 100000</span><br><span class="line">      let result &#x3D; 0</span><br><span class="line">      for (let i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        result +&#x3D; Math.sqrt(Math.cos(Math.sin(42)))</span><br><span class="line">      &#125;</span><br><span class="line">      return result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>优化后的组件代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :style&#x3D;&quot;&#123; opacity: number &#x2F; 300 &#125;&quot;&gt;</span><br><span class="line">    &lt;ChildComp&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComp: &#123;</span><br><span class="line">      methods: &#123;</span><br><span class="line">        heavy () &#123;</span><br><span class="line">          const n &#x3D; 100000</span><br><span class="line">          let result &#x3D; 0</span><br><span class="line">          for (let i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            result +&#x3D; Math.sqrt(Math.cos(Math.sin(42)))</span><br><span class="line">          &#125;</span><br><span class="line">          return result</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      render (h) &#123;</span><br><span class="line">        return h(&#39;div&#39;, this.heavy())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: [&#39;number&#39;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>然后我们在父组件各渲染优化前后的组件 300 个，并在每一帧内部通过修改数据来触发组件的更新，开启 Chrome 的 Performance 面板记录它们的性能，得到如下结果。</p><p>优化前：<br><img src="https://cdn.jsdelivr.net/gh/Jinkun123/blog_imgs/2020-01-12/ChildComponentSplittingOff.png"></p><p>优化后：<br><img src="https://cdn.jsdelivr.net/gh/Jinkun123/blog_imgs/2020-01-12/ChildComponentSplittingOn.png"></p><p>对比这两张图我们可以看到优化后执行 script 的时间要明显少于优化前的，因此性能体验更好。</p><p>那么为什么会有差异呢，我们来看优化前的组件，示例通过一个 heavy 函数模拟了一个耗时的任务，且这个函数在每次渲染的时候都会执行一次，所以每次组件的渲染都会消耗较长的时间执行 JavaScript。</p><p>而优化后的方式是把这个耗时任务 heavy 函数的执行逻辑用子组件 ChildComp 封装了，由于 Vue 的更新是组件粒度的，虽然每一帧都通过数据修改导致了父组件的重新渲染，但是 ChildComp 却不会重新渲染，因为它的内部也没有任何响应式数据的变化。所以优化后的组件不会在每次渲染都执行耗时任务，自然执行的 JavaScript 时间就变少了。</p><p>不过针对这个优化的方式我提出了一些不同的看法，详情可以点开这个 issue，我认为这个场景下的优化用计算属性要比子组件拆分要好。得益于计算属性自身缓存特性，耗时的逻辑也只会在第一次渲染的时候执行，而且使用计算属性也没有额外渲染子组件的开销。</p><p>在实际工作中，使用计算属性是优化性能的场景会有很多，毕竟它也体现了一种空间换时间的优化思想。</p><h4 id="3-Local-variables"><a href="#3-Local-variables" class="headerlink" title="3. Local variables"></a>3. Local variables</h4><p>第三个技巧，局部变量。</p><p>优化前的组件代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :style&#x3D;&quot;&#123; opacity: start &#x2F; 300 &#125;&quot;&gt;&#123;&#123; result &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&#39;start&#39;],</span><br><span class="line">  computed: &#123;</span><br><span class="line">    base () &#123;</span><br><span class="line">      return 42</span><br><span class="line">    &#125;,</span><br><span class="line">    result () &#123;</span><br><span class="line">      let result &#x3D; this.start</span><br><span class="line">      for (let i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">        result +&#x3D; Math.sqrt(Math.cos(Math.sin(this.base))) + this.base * this.base + this.base + this.base * 2 + this.base * 3</span><br><span class="line">      &#125;</span><br><span class="line">      return result</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>优化后的组件代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :style&#x3D;&quot;&#123; opacity: start &#x2F; 300 &#125;&quot;&gt;&#123;&#123; result &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&#39;start&#39;],</span><br><span class="line">  computed: &#123;</span><br><span class="line">    base () &#123;</span><br><span class="line">      return 42</span><br><span class="line">    &#125;,</span><br><span class="line">    result (&#123; base, start &#125;) &#123;</span><br><span class="line">      let result &#x3D; start</span><br><span class="line">      for (let i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">        result +&#x3D; Math.sqrt(Math.cos(Math.sin(base))) + base * base + base + base * 2 + base * 3</span><br><span class="line">      &#125;</span><br><span class="line">      return result</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>然后我们在父组件各渲染优化前后的组件 300 个，并在每一帧内部通过修改数据来触发组件的更新，开启 Chrome 的 Performance 面板记录它们的性能，得到如下结果。</p><p>优化前：<br><img src="https://cdn.jsdelivr.net/gh/Jinkun123/blog_imgs/2020-01-12/LocalVariablesOff.png"></p><p>优化后：<br><img src="https://cdn.jsdelivr.net/gh/Jinkun123/blog_imgs/2020-01-12/LocalVariablesOn.png"></p><p>对比这两张图我们可以看到优化后执行 script 的时间要明显少于优化前的，因此性能体验更好。</p><p>这里主要是优化前后组件的计算属性 result 的实现差异，优化前的组件多次在计算过程中访问 this.base，而优化后的组件会在计算前先用局部变量 base 缓存 this.base，后面则直接访问 base变量。</p><p>那么为啥这个差异会造成性能上的差异呢，原因是你每次访问 this.base 的时候，由于 this.base 是一个响应式对象，所以会触发它的 getter，进而会执行依赖收集相关逻辑代码。类似的逻辑执行多了，像示例这样，几百次循环更新几百个组件，每个组件触发 computed 重新计算，然后又多次执行依赖收集相关逻辑，性能自然就下降了。</p><p>从需求上来说，this.base 执行一次依赖收集就够了，因此我们只需要把它的 getter 求值结果返回给局部变量 base，后续再次访问 base 的时候就不会触发 getter，也不会走依赖收集的逻辑了，性能自然就得到了提升。</p><p>这是一个非常实用的性能优化技巧。因为很多人在开发 Vue.js 项目的时候，每当取变量的时候就习惯性直接写 this.xxx 了，因为大部分人并不会注意到访问 this.xxx 背后做的事情。在访问次数不多的时候，性能问题并没有凸显，但是一旦访问次数变多，比如在一个大循环中多次访问，类似示例这种场景，就会产生性能问题了。</p><p>我之前给 ZoomUI 的 Table 组件做性能优化的时候，在 render table body 的时候就使用了局部变量的优化技巧，并写了 benchmark 做性能对比：渲染 1000 * 10 的表格，ZoomUI Table 的更新数据重新渲染的性能要比 ElementUI 的 Table 性能提升了近一倍。</p><h4 id="4-Reuse-DOM-with-v-show"><a href="#4-Reuse-DOM-with-v-show" class="headerlink" title="4. Reuse DOM with v-show"></a>4. Reuse DOM with v-show</h4><p>第四个技巧，使用 v-show 复用 DOM，你可以查看这个在线示例。</p><p>优化前的组件代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template functional&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;cell&quot;&gt;</span><br><span class="line">    &lt;div v-if&#x3D;&quot;props.value&quot; class&#x3D;&quot;on&quot;&gt;</span><br><span class="line">      &lt;Heavy :n&#x3D;&quot;10000&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;p v-else class&#x3D;&quot;off&quot;&gt;</span><br><span class="line">      &lt;Heavy :n&#x3D;&quot;10000&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p> 优化后的组件代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> &lt;template functional&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;cell&quot;&gt;</span><br><span class="line">    &lt;div v-show&#x3D;&quot;props.value&quot; class&#x3D;&quot;on&quot;&gt;</span><br><span class="line">      &lt;Heavy :n&#x3D;&quot;10000&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;p v-show&#x3D;&quot;!props.value&quot; class&#x3D;&quot;off&quot;&gt;</span><br><span class="line">      &lt;Heavy :n&#x3D;&quot;10000&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>然后我们在父组件各渲染优化前后的组件 200 个，并在每一帧内部通过修改数据来触发组件的更新，开启 Chrome 的 Performance 面板记录它们的性能，得到如下结果。</p><p>优化前：<br><img src="https://cdn.jsdelivr.net/gh/Jinkun123/blog_imgs/2020-01-12/DomShowOff.png"></p><p>优化后：<br><img src="https://cdn.jsdelivr.net/gh/Jinkun123/blog_imgs/2020-01-12/DomShowOn.png"></p><p>对比这两张图我们可以看到优化后执行 script 的时间要明显少于优化前的，因此性能体验更好。</p><p>优化前后的主要区别是用 v-show 指令替代了 v-if 指令来替代组件的显隐，虽然从表现上看，v-show 和 v-if 类似，都是控制组件的显隐，但内部实现差距还是很大的。</p><p>v-if 指令在编译阶段就会编译成一个三元运算符，条件渲染，比如优化前的组件模板经过编译后生成如下渲染函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">  with(this) &#123;</span><br><span class="line">    return _c(&#39;div&#39;, &#123;</span><br><span class="line">      staticClass: &quot;cell&quot;</span><br><span class="line">    &#125;, [(props.value) ? _c(&#39;div&#39;, &#123;</span><br><span class="line">      staticClass: &quot;on&quot;</span><br><span class="line">    &#125;, [_c(&#39;Heavy&#39;, &#123;</span><br><span class="line">      attrs: &#123;</span><br><span class="line">        &quot;n&quot;: 10000</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)], 1) : _c(&#39;p&#39;, &#123;</span><br><span class="line">      staticClass: &quot;off&quot;</span><br><span class="line">    &#125;, [_c(&#39;Heavy&#39;, &#123;</span><br><span class="line">      attrs: &#123;</span><br><span class="line">        &quot;n&quot;: 10000</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)], 1)])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当条件 props.value 的值变化的时候，会触发对应的组件更新，对于 v-if 渲染的节点，由于新旧节点 vnode 不一致，在核心 diff 算法比对过程中，会移除旧的 vnode 节点，创建新的 vnode 节点，那么就会创建新的 Heavy 组件，又会经历 Heavy 组件自身初始化、渲染 vnode、patch 等过程。</p><p>因此使用 v-if 每次更新组件都会创建新的 Heavy 子组件，当更新的组件多了，自然就会造成性能压力。</p><p>而当我们使用 v-show 指令，优化后的组件模板经过编译后生成如下渲染函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">  with(this) &#123;</span><br><span class="line">    return _c(&#39;div&#39;, &#123;</span><br><span class="line">      staticClass: &quot;cell&quot;</span><br><span class="line">    &#125;, [_c(&#39;div&#39;, &#123;</span><br><span class="line">      directives: [&#123;</span><br><span class="line">        name: &quot;show&quot;,</span><br><span class="line">        rawName: &quot;v-show&quot;,</span><br><span class="line">        value: (props.value),</span><br><span class="line">        expression: &quot;props.value&quot;</span><br><span class="line">      &#125;],</span><br><span class="line">      staticClass: &quot;on&quot;</span><br><span class="line">    &#125;, [_c(&#39;Heavy&#39;, &#123;</span><br><span class="line">      attrs: &#123;</span><br><span class="line">        &quot;n&quot;: 10000</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)], 1), _c(&#39;p&#39;, &#123;</span><br><span class="line">      directives: [&#123;</span><br><span class="line">        name: &quot;show&quot;,</span><br><span class="line">        rawName: &quot;v-show&quot;,</span><br><span class="line">        value: (!props.value),</span><br><span class="line">        expression: &quot;!props.value&quot;</span><br><span class="line">      &#125;],</span><br><span class="line">      staticClass: &quot;off&quot;</span><br><span class="line">    &#125;, [_c(&#39;Heavy&#39;, &#123;</span><br><span class="line">      attrs: &#123;</span><br><span class="line">        &quot;n&quot;: 10000</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)], 1)])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当条件 props.value 的值变化的时候，会触发对应的组件更新，对于 v-show 渲染的节点，由于新旧 vnode 一致，它们只需要一直 patchVnode 即可，那么它又是怎么让 DOM 节点显示和隐藏的呢？</p><p>原来在 patchVnode 过程中，内部会对执行 v-show 指令对应的钩子函数 update，然后它会根据 v-show 指令绑定的值来设置它作用的 DOM 元素的 style.display 的值控制显隐。</p><p>因此相比于 v-if 不断删除和创建函数新的 DOM，v-show 仅仅是在更新现有 DOM 的显隐值，所以 v-show 的开销要比 v-if 小的多，当其内部 DOM 结构越复杂，性能的差异就会越大。</p><p>但是 v-show 相比于 v-if 的性能优势是在组件的更新阶段，如果仅仅是在初始化阶段，v-if 性能还要高于 v-show，原因是在于它仅仅会渲染一个分支，而 v-show 把两个分支都渲染了，通过 style.display 来控制对应 DOM 的显隐。</p><p>在使用 v-show 的时候，所有分支内部的组件都会渲染，对应的生命周期钩子函数都会执行，而使用 v-if 的时候，没有命中的分支内部的组件是不会渲染的，对应的生命周期钩子函数都不会执行。</p><p>因此你要搞清楚它们的原理以及差异，才能在不同的场景使用适合的指令。</p><p>总结一下，用自己的话来说就是：v-if操作虚拟DOM，v-show是CSS的display；所以v-if有局部卸载添加节点 更耗费性能，而v-show并没有删除所以性能更优，<br>另外补充一下 v-if更适用于首次加载之后改变次数较少，v-show适合频繁切换。</p><h4 id="5-KeepAlive"><a href="#5-KeepAlive" class="headerlink" title="5. KeepAlive"></a>5. KeepAlive</h4><p>第五个技巧，使用 KeepAlive 组件缓存 DOM，你可以查看这个在线示例。</p><p>优化前的组件代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-view&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>优化后的组件代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;keep-alive&gt;</span><br><span class="line">      &lt;router-view&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;keep-alive&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>我们点击按钮在 Simple page 和 Heavy Page 之间切换，会渲染不同的视图，其中 Heavy Page 的渲染非常耗时。我们开启 Chrome 的 Performance 面板记录它们的性能，然后分别在优化前后执行如上的操作，会得到如下结果。</p><p>优化前：<br><img src="https://cdn.jsdelivr.net/gh/Jinkun123/blog_imgs/2020-01-12/KeepAliveOff.png"></p><p>优化后：<br><img src="https://cdn.jsdelivr.net/gh/Jinkun123/blog_imgs/2020-01-12/KeepAliveNo.png"></p><p>对比这两张图我们可以看到优化后执行 script 的时间要明显少于优化前的，因此性能体验更好。</p><p>在非优化场景下，我们每次点击按钮切换路由视图，都会重新渲染一次组件，渲染组件就会经过组件初始化，render、patch 等过程，如果组件比较复杂，或者嵌套较深，那么整个渲染耗时就会很长。</p><p>而在使用 KeepAlive 后，被 KeepAlive 包裹的组件在经过第一次渲染后，的 vnode 以及 DOM 都会被缓存起来，然后再下一次再次渲染该组件的时候，直接从缓存中拿到对应的 vnode 和 DOM，然后渲染，并不需要再走一次组件初始化，render 和 patch 等一系列流程，减少了 script 的执行时间，性能更好。</p><p>但是使用 KeepAlive 组件并非没有成本，因为它会占用更多的内存去做缓存，这是一种典型的空间换时间优化思想的应用。</p><h4 id="6-Deferred-features"><a href="#6-Deferred-features" class="headerlink" title="6. Deferred features"></a>6. Deferred features</h4><p>第六个技巧，使用 Deferred 组件延时分批渲染组件。</p><p>优化前的组件代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;deferred-off&quot;&gt;</span><br><span class="line">    &lt;VueIcon icon&#x3D;&quot;fitness_center&quot; class&#x3D;&quot;gigantic&quot;&#x2F;&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;h2&gt;I&#39;m an heavy page&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;Heavy v-for&#x3D;&quot;n in 8&quot; :key&#x3D;&quot;n&quot;&#x2F;&gt;</span><br><span class="line">    &lt;Heavy class&#x3D;&quot;super-heavy&quot; :n&#x3D;&quot;9999999&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>优化后的组件代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;deferred-on&quot;&gt;</span><br><span class="line">    &lt;VueIcon icon&#x3D;&quot;fitness_center&quot; class&#x3D;&quot;gigantic&quot;&#x2F;&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;h2&gt;I&#39;m an heavy page&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;template v-if&#x3D;&quot;defer(2)&quot;&gt;</span><br><span class="line">      &lt;Heavy v-for&#x3D;&quot;n in 8&quot; :key&#x3D;&quot;n&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;Heavy v-if&#x3D;&quot;defer(3)&quot; class&#x3D;&quot;super-heavy&quot; :n&#x3D;&quot;9999999&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Defer from &#39;@&#x2F;mixins&#x2F;Defer&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  mixins: [</span><br><span class="line">    Defer(),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>我们点击按钮在 Simple page 和 Heavy Page 之间切换，会渲染不同的视图，其中 Heavy Page 的渲染非常耗时。我们开启 Chrome 的 Performance 面板记录它们的性能，然后分别在优化前后执行如上的操作，会得到如下结果。</p><p>优化前：<br><img src="https://cdn.jsdelivr.net/gh/Jinkun123/blog_imgs/2020-01-12/DeferredFeaturesOff.png"></p><p>对比这两张图我们可以发现，优化前当我们从 Simple Page 切到 Heavy Page 的时候，在一次 Render 接近结尾的时候，页面渲染的仍然是 Simple Page，会给人一种页面卡顿的感觉。而优化后当我们从 Simple Page 切到 Heavy Page 的时候，在一次 Render 靠前的位置页面就已经渲染了 Heavy Page 了，并且 Heavy Page 是渐进式渲染出来的。</p><p>优化前后的差距主要是后者使用了 Defer 这个 mixin，那么它具体是怎么工作的，我们来一探究竟：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">export default function (count &#x3D; 10) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        displayPriority: 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    mounted () &#123;</span><br><span class="line">      this.runDisplayPriority()</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    methods: &#123;</span><br><span class="line">      runDisplayPriority () &#123;</span><br><span class="line">        const step &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">          requestAnimationFrame(() &#x3D;&gt; &#123;</span><br><span class="line">            this.displayPriority++</span><br><span class="line">            if (this.displayPriority &lt; count) &#123;</span><br><span class="line">              step()</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        step()</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      defer (priority) &#123;</span><br><span class="line">        return this.displayPriority &gt;&#x3D; priority</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Defer 的主要思想就是把一个组件的一次渲染拆成多次，它内部维护了 displayPriority 变量，然后在通过 requestAnimationFrame 在每一帧渲染的时候自增，最多加到 count。然后使用 Defer mixin 的组件内部就可以通过 v-if=”defer(xxx)” 的方式来控制在 displayPriority 增加到 xxx 的时候渲染某些区块了。</p><p>当你有渲染耗时的组件，使用 Deferred 做渐进式渲染是不错的注意，它能避免一次 render 由于 JS 执行时间过长导致渲染卡住的现象。</p><h4 id="7-Time-slicing"><a href="#7-Time-slicing" class="headerlink" title="7. Time slicing"></a>7. Time slicing</h4><p>第七个技巧，使用 Time slicing 时间片切割技术。</p><p>优化前的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetchItems (&#123; commit &#125;, &#123; items &#125;) &#123;</span><br><span class="line">  commit(&#39;clearItems&#39;)</span><br><span class="line">  commit(&#39;addItems&#39;, items)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fetchItems (&#123; commit &#125;, &#123; items, splitCount &#125;) &#123;</span><br><span class="line">  commit(&#39;clearItems&#39;)</span><br><span class="line">  const queue &#x3D; new JobQueue()</span><br><span class="line">  splitArray(items, splitCount).forEach(</span><br><span class="line">    chunk &#x3D;&gt; queue.addJob(done &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 分时间片提交数据</span><br><span class="line">      requestAnimationFrame(() &#x3D;&gt; &#123;</span><br><span class="line">        commit(&#39;addItems&#39;, chunk)</span><br><span class="line">        done()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">  await queue.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先通过点击 Genterate items 按钮创建 10000 条假数据，然后分别在开启和关闭 Time-slicing 的情况下点击 Commit items 按钮提交数据，开启 Chrome 的 Performance 面板记录它们的性能，会得到如下结果。</p><p>优化前：<br><img src="https://cdn.jsdelivr.net/gh/Jinkun123/blog_imgs/2020-01-12/TimeSlicingOff.png"></p><p>优化后：<br><img src="https://cdn.jsdelivr.net/gh/Jinkun123/blog_imgs/2020-01-12/TimeSlicingOn.png"></p><p>对比这两张图我们可以发现，优化前总的 script 执行时间要比优化后的还要少一些，但是从实际的观感上看，优化前点击提交按钮，页面会卡死 1.2 秒左右，在优化后，页面不会完全卡死，但仍然会有渲染卡顿的感觉。</p><p>那么为什么在优化前页面会卡死呢？因为一次性提交的数据过多，内部 JS 执行时间过长，阻塞了 UI 线程，导致页面卡死。</p><p>优化后，页面仍有卡顿，是因为我们拆分数据的粒度是 1000 条，这种情况下，重新渲染组件仍然有压力，我们观察 fps 只有十几，会有卡顿感。通常只要让页面的 fps 达到 60，页面就会非常流畅，如果我们把数据拆分粒度变成 100 条，基本上 fps 能达到 50 以上，虽然页面渲染变流畅了，但是完成 10000 条数据总的提交时间还是变长了。</p><p>使用 Time slicing技术可以避免页面卡死，通常我们在这种耗时任务处理的时候会加一个 loading 效果，在这个示例中，我们可以开启 loading animation，然后提交数据。对比发现，优化前由于一次性提交数据过多，JS 一直长时间运行，阻塞 UI 线程，这个 loading 动画是不会展示的，而优化后，由于我们拆成多个时间片去提交数据，单次 JS 运行时间变短了，这样 loading 动画就有机会展示了。</p><p><code>这里要注意的一点，虽然我们拆时间片使用了 requestAnimationFrame API，但是使用 requestAnimationFrame 本身是不能保证满帧运行的，requestAnimationFrame 保证的是在浏览器每一次重绘后会执行对应传入的回调函数，想要保证满帧，只能让 JS 在一个 Tick 内的运行时间不超过 17ms。</code></p><h4 id="8-Non-reactive-data"><a href="#8-Non-reactive-data" class="headerlink" title="8. Non-reactive data"></a>8. Non-reactive data</h4><p>第八个技巧，使用 Non-reactive data ，你可以查看这个在线示例。</p><p>优化前代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const data &#x3D; items.map(</span><br><span class="line">  item &#x3D;&gt; (&#123;</span><br><span class="line">    id: uid++,</span><br><span class="line">    data: item,</span><br><span class="line">    vote: 0</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>优化后代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const data &#x3D; items.map(</span><br><span class="line">  item &#x3D;&gt; optimizeItem(item)</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">function optimizeItem (item) &#123;</span><br><span class="line">  const itemData &#x3D; &#123;</span><br><span class="line">    id: uid++,</span><br><span class="line">    vote: 0</span><br><span class="line">  &#125;</span><br><span class="line">  Object.defineProperty(itemData, &#39;data&#39;, &#123;</span><br><span class="line">    &#x2F;&#x2F; Mark as non-reactive</span><br><span class="line">    configurable: false,</span><br><span class="line">    value: item</span><br><span class="line">  &#125;)</span><br><span class="line">  return itemData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是前面的示例，我们先通过点击 Genterate items 按钮创建 10000 条假数据，然后分别在开启和关闭 Partial reactivity 的情况下点击 Commit items 按钮提交数据，开启 Chrome 的 Performance 面板记录它们的性能，会得到如下结果。</p><p>优化前：<br><img src="https://cdn.jsdelivr.net/gh/Jinkun123/blog_imgs/2020-01-12/Non-reactiveOff.png"></p><p>优化后：<br><img src="https://cdn.jsdelivr.net/gh/Jinkun123/blog_imgs/2020-01-12/Non-reactiveOn.png"></p><p>对比这两张图我们可以看到优化后执行 script 的时间要明显少于优化前的，因此性能体验更好。</p><p>之所以有这种差异，是因为内部提交的数据的时候，会默认把新提交的数据也定义成响应式，如果数据的子属性是对象形式，还会递归让子属性也变成响应式，因此当提交数据很多的时候，这个过程就变成了一个耗时过程。</p><p>而优化后我们把新提交的数据中的对象属性 data 手动变成了 configurable 为 false，这样内部在 walk 时通过 Object.keys(obj) 获取对象属性数组会忽略 data，也就不会为 data 这个属性 defineReactive，由于 data 指向的是一个对象，这样也就会减少递归响应式的逻辑，相当于减少了这部分的性能损耗。数据量越大，这种优化的效果就会更明显。</p><p>其实类似这种优化的方式还有很多，比如我们在组件中定义的一些数据，也不一定都要在 data 中定义。有些数据我们并不是用在模板中，也不需要监听它的变化，只是想在组件的上下文中共享这个数据，这个时候我们可以仅仅把这个数据挂载到组件实例 this 上，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.scroll &#x3D; null</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.scroll &#x3D; new BScroll(this.$el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以在组件上下文中共享 scroll 对象了，即使它不是一个响应式对象。</p><h4 id="9-Virtual-scrolling"><a href="#9-Virtual-scrolling" class="headerlink" title="9. Virtual scrolling"></a>9. Virtual scrolling</h4><p>第九个技巧，使用 Virtual scrolling。</p><p>优化前组件的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;items no-v&quot;&gt;</span><br><span class="line">  &lt;FetchItemViewFunctional</span><br><span class="line">    v-for&#x3D;&quot;item of items&quot;</span><br><span class="line">    :key&#x3D;&quot;item.id&quot;</span><br><span class="line">    :item&#x3D;&quot;item&quot;</span><br><span class="line">    @vote&#x3D;&quot;voteItem(item)&quot;</span><br><span class="line">  &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>优化后代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;recycle-scroller</span><br><span class="line">  class&#x3D;&quot;items&quot;</span><br><span class="line">  :items&#x3D;&quot;items&quot;</span><br><span class="line">  :item-size&#x3D;&quot;24&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;template v-slot&#x3D;&quot;&#123; item &#125;&quot;&gt;</span><br><span class="line">    &lt;FetchItemView</span><br><span class="line">      :item&#x3D;&quot;item&quot;</span><br><span class="line">      @vote&#x3D;&quot;voteItem(item)&quot;</span><br><span class="line">    &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;recycle-scroller&gt;</span><br></pre></td></tr></table></figure><p>还是前面的示例，我们需要开启 View list，然后点击 Genterate items 按钮创建 10000 条假数据（注意，线上示例最多只能创建 1000 条数据，实际上 1000 条数据并不能很好地体现优化的效果，所以我修改了源码的限制，本地运行，创建了 10000 条数据），然后分别在 Unoptimized 和 RecycleScroller 的情况下点击 Commit items 按钮提交数据，滚动页面，开启 Chrome 的 Performance 面板记录它们的性能，会得到如下结果。</p><p>优化前：<br><img src="https://cdn.jsdelivr.net/gh/Jinkun123/blog_imgs/2020-01-12/VirtualScrollingOff.png"></p><p>优化后：<br><img src="https://cdn.jsdelivr.net/gh/Jinkun123/blog_imgs/2020-01-12/VirtualScrollingOn.png"></p><p>对比这两张图我们发现，在非优化的情况下，10000 条数据在滚动情况下 fps 只有个位数，在非滚动情况下也就十几，原因是非优化场景下渲染的 DOM 太多，渲染本身的压力很大。优化后，即使 10000 条数据，在滚动情况下的 fps 也能有 30 多，在非滚动情况下可以达到 60 满帧。</p><p>之所以有这个差异，是因为虚拟滚动的实现方式：是只渲染视口内的 DOM。这样总共渲染的 DOM 数量就很少了，自然性能就会好很多。</p><p>虚拟滚动组件也是 Guillaume Chau 写的，感兴趣的同学可以去研究它的源码实现。它的基本原理就是监听滚动事件，动态更新需要显示的 DOM 元素，计算出它们在视图中的位移。</p><p>虚拟滚动组件也并非没有成本，因为它需要在滚动的过程中实时去计算，所以会有一定的 script 执行的成本。因此如果列表的数据量不是很大的情况，我们使用普通的滚动就足够了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过这篇文章，我希望你能了解到 Vue.js 的九种性能优化技巧，并能运用到实际的开发项目中。除了上述技巧之外，还有懒加载图片、懒加载组件、异步组件等等常用的性能优化手段。</p><p>在做性能优化前，我们需要分析性能的瓶颈在哪，才能因地制宜。另外，性能优化都需要数据支撑的，你在做任何性能优化前，需要先采集优化前的数据，这样优化后才能够通过数据对比看到优化的效果。</p><p>希望你在日后的开发过程中，不再只满足于实现需求，写每一行代码的时候，都能思考它可能产生的性能方面的影响。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>vue-9-perf-secrets slidse：<a href="https://slides.com/akryum/vueconfus-2019">https://slides.com/akryum/vueconfus-2019</a></li><li>vue-9-perf-secrets 分享演讲视频：<a href="https://www.vuemastery.com/conferences/vueconf-us-2019/9-performance-secrets-revealed/">https://www.vuemastery.com/conferences/vueconf-us-2019/9-performance-secrets-revealed/</a></li><li>vue-9-perf-secrets 项目源码：<a href="https://github.com/Akryum/vue-9-perf-secrets">https://github.com/Akryum/vue-9-perf-secrets</a></li><li>vue-9-perf-secrets 在线演示地址：<a href="https://vue-9-perf-secrets.netlify.app/">https://vue-9-perf-secrets.netlify.app/</a></li><li>vue-9-perf-secrets 讨论 issue：<a href="https://github.com/Akryum/vue-9-perf-secrets/issues/1">https://github.com/Akryum/vue-9-perf-secrets/issues/1</a></li><li>vue-virtual-scroller 项目源码：<a href="https://github.com/Akryum/vue-virtual-scroller">https://github.com/Akryum/vue-virtual-scroller</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3+vite基础搭建</title>
      <link href="2021/09/17/vue-frame/"/>
      <url>2021/09/17/vue-frame/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为一个小前端，基础菜的一笔，不过还是要跟随技术得发展和学习，此篇为初学篇，大佬勿喷！！！</p><p>Vue3.0 的创建，我们可以使用vue-CLI,WebPack,这两种工具我们在Vue2x中经常使用到，这里我们就不再多讲， 此次我们重点讲述<strong>vite工具</strong>创建Vue3.0项目：</p><h4 id="什么是Vite"><a href="#什么是Vite" class="headerlink" title="什么是Vite?"></a>什么是Vite?</h4><ol><li>Vite是Vue开发者开发的一款意图取代WebPack的工具。</li><li>其原理是利用ES6的import会发送请求去加载文件的特性，拦截这些请求，做一些预编译，省去WebPack冗长的打包时间。</li></ol><p>废话不多说，现在开始：</p><h5 id="1-安装Vite"><a href="#1-安装Vite" class="headerlink" title="1. 安装Vite:"></a>1. 安装Vite:</h5><p>通过cmd命令行工具，在你需要创建Vue3.0项目饿文件夹中执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-vite-app</span><br></pre></td></tr></table></figure><h5 id="2-利用Vite创建Vue3-0项目："><a href="#2-利用Vite创建Vue3-0项目：" class="headerlink" title="2.利用Vite创建Vue3.0项目："></a>2.利用Vite创建Vue3.0项目：</h5><ol><li><p>首先创建项目名称，在上一步完成之后接着执行如下命令：create-vite-app projectName   注意这里的projectName 是你的项目名称，你可以随意取，但是名称里最好不要有大写字母，cmd命令行里创建带有大写字母的文件时，会有错误提示。</p></li><li><p>当文见创建好之后，会提示你执行：</p><pre><code>    cd  projectName     npm install      npm run dev</code></pre></li></ol><h5 id="3-安装依赖运行项目："><a href="#3-安装依赖运行项目：" class="headerlink" title="3.安装依赖运行项目："></a>3.安装依赖运行项目：</h5><ol><li>完成上一步操作之后，我们就要开始安装Vue项目运行的依赖了，执行命令语句  cd  projectName   进入你刚刚创建好的项目文件夹下，因为接下来的项目依赖都会安装到这个文件夹之下。</li><li>在命令行中执行：npm install   开始安装依赖，这个过程可能需要几分钟，安装成功。</li></ol><h5 id="4-开始运行项目："><a href="#4-开始运行项目：" class="headerlink" title="4.开始运行项目："></a>4.开始运行项目：</h5><p>在命令行中执行：<br><code>npm run dev   </code><br>运行成功后会提示你在浏览器中执行 localhost:3000    即可访问创建好的Vue项目工程。</p><p>目录大概如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Jinkun123/blog_imgs/2020-01-12/catalogue.png"></p><h5 id="Vite配置，插件ui引入"><a href="#Vite配置，插件ui引入" class="headerlink" title="Vite配置，插件ui引入"></a>Vite配置，插件ui引入</h5><p><strong>Vite简单配置一下，更详细得请百度官网</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineConfig &#125; from &#39;vite&#39;</span><br><span class="line">import vue from &#39;@vitejs&#x2F;plugin-vue&#39;</span><br><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line">console.log(path.resolve(__dirname, &#39;.&#x2F;src&#39;))</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;vitejs.dev&#x2F;config&#x2F;</span><br><span class="line">export default defineConfig(&#123;</span><br><span class="line">  &#x2F;&#x2F; vite.config.js # or vite.config.ts</span><br><span class="line">  plugins: [vue()],</span><br><span class="line">  &quot;resolve.alias&quot;: &#123;</span><br><span class="line">    &#39;@&#39;: path.resolve(__dirname, &#39;src&#39;),</span><br><span class="line">    &#39;view&#39;: path.resolve(__dirname, &#39;src&#x2F;view&#39;),</span><br><span class="line">    &#39;com&#39;: path.resolve(__dirname, &#39;src&#x2F;components&#39;),</span><br><span class="line">    &#39;api&#39;: path.resolve(__dirname, &#39;src&#x2F;api&#39;),</span><br><span class="line">    &#39;utils&#39;: path.resolve(__dirname, &#39;src&#x2F;utils&#39;),</span><br><span class="line">  &#125;,</span><br><span class="line">  server:&#123;</span><br><span class="line">    hostname: &#39;0.0.0.0&#39;, &#x2F;&#x2F; 默认是 localhost</span><br><span class="line">    port: &#39;8080&#39;, &#x2F;&#x2F; 默认是 3000 端口</span><br><span class="line">    open: true, &#x2F;&#x2F; 浏览器自动打开</span><br><span class="line">    https: false, &#x2F;&#x2F; 是否开启 https</span><br><span class="line">    ssr: false, &#x2F;&#x2F; 服务端渲染</span><br><span class="line">    base: &#39;.&#x2F;&#39;, &#x2F;&#x2F; 生产环境下的公共路径</span><br><span class="line">    outDir: &#39;dist&#39;, &#x2F;&#x2F; 打包构建输出路径，默认 dist ，如果路径存在，构建之前会被删除</span><br><span class="line">    proxy: &#123; &#x2F;&#x2F; 本地开发环境通过代理实现跨域，生产环境使用 nginx 转发</span><br><span class="line">      &#39;&#x2F;api&#39;: &#123;</span><br><span class="line">        target: &#39;http:&#x2F;&#x2F;poetry.apiopen.top&#39;, &#x2F;&#x2F; 后端服务实际地址</span><br><span class="line">        secure: false,  &#x2F;&#x2F; 如果是https接口，需要配置这个参数</span><br><span class="line">        ws: true,&#x2F;&#x2F;是否代理websockets</span><br><span class="line">        changeOrigin: true,</span><br><span class="line">        rewrite: path &#x3D;&gt; path.replace(&#x2F;^\&#x2F;api&#x2F;, &#39;&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>element引用</strong></p><p>elementui官方  为配合vue3 推出element-plus<br>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install element-plus --save</span><br></pre></td></tr></table></figure><p><strong>main.js全局引用，局部安装详见官方文档</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;  &#x2F;&#x2F;引入路由</span><br><span class="line">import axios from &#39;axios&#39; &#x2F;&#x2F;引入axios</span><br><span class="line">import store from &#39;.&#x2F;store&#39; &#x2F;&#x2F;引入Vuex</span><br><span class="line">import ElementPlus from &#39;element-plus&#39; &#x2F;&#x2F;引入elementui plus</span><br><span class="line">import &#39;element-plus&#x2F;dist&#x2F;index.css&#39;  &#x2F;&#x2F;引入elementui css</span><br><span class="line">const app&#x3D;createApp(App); &#x2F;&#x2F;创建APP实例</span><br><span class="line">app.config.globalProperties.$axops&#x3D;axios</span><br><span class="line">&#x2F;&#x2F; base api</span><br><span class="line">console.log(import.meta.env.VITE_NODE_ENV);</span><br><span class="line">app</span><br><span class="line">.use(router)</span><br><span class="line">.use(store)</span><br><span class="line">.use(ElementPlus)</span><br><span class="line">.mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure><p><code>Vue2 和 Vue3 全局引入稍有不同 </code></p><h5 id="5-环境变量配置"><a href="#5-环境变量配置" class="headerlink" title="5.环境变量配置"></a>5.环境变量配置</h5><p>创建 .env.development (本地开发环境)  .env.production(生产环境)</p><p><code>(注意环境变量 名字需以 VITE_ 为开头 vite 要求识别)</code></p><p>和vue2一样 修改 package.json 文件 scripts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;vite&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;vite --mode development&quot;,</span><br><span class="line">    &quot;prod&quot;: &quot;vite --mode production&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;vite build --mode production&quot;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> vite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue组件传值</title>
      <link href="2021/09/15/value-transmission/"/>
      <url>2021/09/15/value-transmission/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为一个小前端，基础菜的一笔，然后还记忆不太好，为了巩固和记忆，大佬勿喷！！！</p><p><strong>vue的组件传值分为三种方式：父传子、子传父、非父子组件传值引用官网的一句话：父子组件的关系可以总结为 prop 向下传递，事件向上传递父组件通过 prop 给子组件下发数据，子组件通过事件给父组件发送消息，如下图所示：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Jinkun123/blog_imgs/2020-01-12/technologicalprocess.png"></p><p>下面我们就开始用代码（<code>一言不合就上代码</code>）详细的介绍vue组件传值的三种方式</p><h3 id="Vue组件传值"><a href="#Vue组件传值" class="headerlink" title="Vue组件传值"></a>Vue组件传值</h3><ol><li><p><strong>父传子</strong><br>子组件的代码：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;container&quot;&gt;</span><br><span class="line">        &#123;&#123;msg&#125;&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  props:&#123;</span><br><span class="line">    msg: String</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">#container&#123;</span><br><span class="line">    color: red;</span><br><span class="line">    margin-top: 50px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>父组件的代码：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;container&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;text&quot; @change&#x3D;&quot;dataChange&quot;&gt;</span><br><span class="line">        &lt;Child :msg&#x3D;&quot;text&quot;&gt;&lt;&#x2F;Child&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from &quot;@&#x2F;components&#x2F;Child&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      text: &quot;父组件的值&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    dataChange(data)&#123;</span><br><span class="line">        this.msg &#x3D; data</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p><code>父传子的实现方式就是通过props属性，子组件通过props属性接收从父组件传过来的值，而父组件传值的时候使用 v-bind 将子组件中预留的变量名绑定为data里面的数据即可</code></p></li><li><p><strong>子传父</strong></p><p> 子组件代码：</p><pre><code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;container&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;msg&quot;&gt;</span><br><span class="line">        &lt;button @click&#x3D;&quot;setData&quot;&gt;传递到父组件&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &quot;传递给父组件的值&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    setData() &#123;</span><br><span class="line">      this.$emit(&quot;getData&quot;, this.msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">#container &#123;</span><br><span class="line">  color: red;</span><br><span class="line">  margin-top: 50px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></code></pre><p> 父组件代码：</p><pre><code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;container&quot;&gt;</span><br><span class="line">        &lt;Child @getData&#x3D;&quot;getData&quot;&gt;&lt;&#x2F;Child&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from &quot;@&#x2F;components&#x2F;Child&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &quot;父组件默认值&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getData(data) &#123;</span><br><span class="line">      this.msg &#x3D; data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></code></pre><p> <code>子传父的实现方式就是用了 this.$emit 来遍历 getData 事件，首先用按钮       来触发 setData 事件，在 setData 中 用 this.$emit 来遍历 getData 事           件，最后返回 this.msg</code></p><p> <strong>总结：</strong></p><ul><li><pre><code>子组件中需要以某种方式例如点击事件的方法来触发一个自定义事件</code></pre></li><li><pre><code>将需要传的值作为$emit的第二个参数，该值将作为实参传给响应自定义事件的方法</code></pre></li><li> 在父组件中注册子组件并在子组件标签上绑定对自定义事件的监听</li></ul></li><li><p><strong>非父子</strong> </p><p> <code>vue 中没有直接子对子传参的方法，建议将需要传递数据的子组件，都合并为一个组件如果一定需要子对子传参，可以先从传到父组件，再传到子组件（相当于一个公共bus文件）为了便于开发，vue 推出了一个状态管理工具 vuex，可以很方便实现组件之间的参数传递</code></p></li></ol><h3 id="poprs的详解"><a href="#poprs的详解" class="headerlink" title="poprs的详解"></a>poprs的详解</h3><p><strong>看一下官方文档：</strong></p><ul><li><p>组件实例的作用域是孤立的。这意味着不能 (也不应该) 在子组件的模板内直接      引用父组件的数据。父组件的数据需要通过 prop 才能下发到子组件中。</p></li><li><p>也就是props是子组件访问父组件数据的唯一接口。</p></li></ul><p><strong>详细一点解释就是：</strong></p><ul><li>一个组件可以直接在模板里面渲染data里面的数据（双大括号）。</li><li>子组件不能直接在模板里面渲染父元素的数据。</li><li>如果子组件想要引用父元素的数据，那么就在prop里面声明一个变量（比如a），这个变量就可以引用父元素的数据。然后在模板里渲染这个变量（前面的a），这时候渲染出来的就是父元素里面的数据。</li></ul><p><strong>重点</strong></p><p><code>单向数据流： props是单向绑定的</code></p><ul><li>当父组件的属性变化时，将传导给子组件，但是反过来不会。</li><li>每次父组件更新时，子组件的所有 prop 都会更新为最新值。</li><li>不要在子组件内部改变 prop。如果你这么做了，Vue 会在控制台给出警告。</li></ul><p><code>在两种情况下，我们很容易忍不住想去修改 prop 中数据： </code></p><ul><li>Prop 作为初始值传入后，子组件想把它当作局部数据来用。</li><li>Prop 作为原始数据传入，由子组件处理成其它数据输出。</li></ul><p>对这两种情况，正确的应对方式是<br>定义一个局部变量，并用 prop 的值初始化它：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">props: [&#39;initialCounter&#39;], </span><br><span class="line">  data: function () &#123; </span><br><span class="line">      return &#123;counter: this.initialCounter &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></code></pre><p>定义一个计算属性，处理 prop 的值并返回：</p><pre><code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">props: [&#39;size&#39;], </span><br><span class="line">    computed: &#123; normalizedSize: function () &#123; </span><br><span class="line">    return   this.size.trim().toLowerCase() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p><code>注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。</code></p><p>举个例子：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app3&quot;&gt;</span><br><span class="line">    &lt;my-component :object&#x3D;&#39;object&#39;&gt;&lt;&#x2F;my-component&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;vuejs.org&#x2F;js&#x2F;vue.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    var mycom &#x3D; Vue.component(&#39;my-component&#39;, &#123;</span><br><span class="line">        &#x2F;&#x2F;添加一个input改变子组件的childOject，那么父元素的object也会被改变，但是Vue没有报错！</span><br><span class="line">        template: &#39;&lt;p&gt;&#123;&#123; object.name &#125;&#125; is &#123;&#123; object.age &#125;&#125; years old.&lt;br&gt;&lt;input v-model&#x3D;&quot;childObject.name&quot; type&#x3D;&quot;text&quot;&gt;&lt;&#x2F;p&gt;&#39;,</span><br><span class="line">        props: [&#39;object&#39;,&#39;school&#39;],</span><br><span class="line">        data: function () &#123;</span><br><span class="line">            &#x2F;&#x2F; 子组件的childObject 和 父组件的object 指向同一个对象</span><br><span class="line">            return &#123;</span><br><span class="line">                childObject: this.object</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    var app3 &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app3&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            object:&#123;</span><br><span class="line">                name: &#39;Xueying&#39;,</span><br><span class="line">                age: &#39;21&#39;,</span><br><span class="line">            &#125;,</span><br><span class="line">            school:&#39;SCUT&#39;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre><ol><li>props验证<br>可以为prop指定验证规则，如果传入的数据不符合要求，Vue会发出警告。</li></ol><p>具体验证规则见官方文档：Prop验证规则</p><ol start="2"><li>$parent<br> $parent 也可以用来访问父组件的数据。</li></ol><p>而且子组件可以通过$parent 来直接修改父组件的数据，不会报错！可以使用props的时候，尽量使用props显式地传递数据（可以很清楚很快速地看出子组件引用了父组件的哪些数据）。另外在一方面，直接在子组件中修改父组件的数据是很糟糕的做法，props单向数据流就没有这种顾虑了。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件 </tag>
            
            <tag> 数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node 版本管理  nvm nrm</title>
      <link href="2021/09/09/nrm-mvm/"/>
      <url>2021/09/09/nrm-mvm/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为一个小前端，是否因为搭建环境烦恼过，是否因为 npm 等国外镜像踩坑过，不要怕，接下来跟着我一步步搭建适合自己的开发环境吧！！！</p><h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><p>这个不用说了吧，我们经常和他打交道，无论是 gulp、webpack和parcel等打包工具，还是各种脚手架的工具，都离不开node环境的支持，接下来我就介绍一下我常用的一些工具和模块。</p><h2 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h2><p>管理node版本，通过nvm我们可以同时安装/切换不同的node版本不过,nvm不支持window版本,但是有替代方案,就是nvm-window,具体为什么nvm为何不支持windows平台?这里就不做谈论了…</p><blockquote><p> ps: nvm-window 下载链接，如果网速快就不需要在这里下载了，github 下载链接，建议下载nvm-setup.zip会帮你配置好环境变量</p></blockquote><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>如果没什么特别要求，无脑下一步即可</p><ol><li>如果之前已安装node,作者的建议是卸载原有的node版本,避免发生冲突</li><li>配置 setting.txt 文件,主要是配置为国内镜像源镜像源<br>配置文件在：C:\Users\用户名\AppData\Roaming\nvm 下（如果和我一下，无脑下一步的话）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_mirror: https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;node&#x2F;</span><br><span class="line">npm_mirror: https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;npm&#x2F;</span><br></pre></td></tr></table></figure><blockquote><p>ps:如果遇到Powershell下禁止执行脚本的问题,请用管理员打开Powershell执行set-ExecutionPolicy RemoteSigned，选择 y 即可</p></blockquote><p>常用命令</p><ol><li><p>可列出已安装的 node 版本 nvm list/nvm ls</p><pre><code> nvm ls</code></pre></li><li><p>安装指定版本的 node nvm install[arch]</p><pre><code> nvm install latest # latest表示安装最新版</code></pre></li></ol><blockquote><p>ps: arch 为可选的平台架构项（32 位/64 位），，默认为系统平台对应的版本，若设置为 all，则同时安装两个版本。</p></blockquote><ol start="3"><li><p>卸载指定版本 nvm uninstall</p><pre><code> nvm uninstall 13.6.0 # latest表示安装最新版</code></pre></li><li><p>设置镜像源 nvm node_mirror</p><ul><li><p>设置node镜像源</p><pre><code> nvm node_mirror https://npm.taobao.org/mirrors/node/ </code></pre></li><li><p>设置npm镜像源</p><pre><code> nvm npm_mirror https://npm.taobao.org/mirrors/node/</code></pre></li></ul></li></ol><h2 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h2><p>众所周知的一点，npm 日常会挂掉，还时不时丢包，所以我们需要一款切换源的工具，来帮我们解决这个问题。</p><blockquote><p>ps: 虽然可以手动切换源，但是相对来讲还是比较麻烦的，所以推荐使用工具来帮我们完成这件事</p></blockquote><h4 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h4><p><code>npm install -g nrm</code></p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ol><li>列出当前支持切换的源<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nrm ls* npm -------- https:&#x2F;&#x2F;registry.npmjs.org&#x2F;</span><br><span class="line">yarn ------- https:&#x2F;&#x2F;registry.yarnpkg.com&#x2F;</span><br><span class="line">cnpm ------- http:&#x2F;&#x2F;r.cnpmjs.org&#x2F;</span><br><span class="line">taobao ----- https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br><span class="line">nj --------- https:&#x2F;&#x2F;registry.nodejitsu.com&#x2F;</span><br><span class="line">npmMirror -- https:&#x2F;&#x2F;skimdb.npmjs.com&#x2F;registry&#x2F;</span><br><span class="line">edunpm ----- http:&#x2F;&#x2F;registry.enpmjs.org&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>使用 taobao 源作为默认的 npm 源<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nrm use taobao    Registry has been set to: https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br></pre></td></tr></table></figure></li><li>测试源速度<ul><li>测试一个源<br><code>nrm test npm</code></li><li>测试所有源<br><code>nrm test</code></li></ul></li><li>访问源的主页<br><code>nrm home taobao</code></li></ol><blockquote><p>ps: 此命令会在默认浏览器中打开淘宝源的主页：<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org/</a></p></blockquote><ol start="5"><li>添加/刪除 一个源</li></ol><ul><li><p>添加源：nrm add[home]，home 参数主要用于访问源的主页（可选）<br><code>nrm add gating http://npm.gatings.com/  http://gatings.cn/</code></p></li><li><p>刪除源：nrm del<br><code>nrm del gating</code></p></li></ul><blockquote><p>ps: nrm del 命令不能删除 nrm 自己内置的源。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nvm </tag>
            
            <tag> nrm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA试用</title>
      <link href="2021/09/09/Eval/"/>
      <url>2021/09/09/Eval/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Eval-Reset试用"><a href="#Eval-Reset试用" class="headerlink" title="Eval Reset试用"></a>Eval Reset试用</h1><p>1、下载插件下载地址：<a href="https://plugins.zhile.io/files/ide-eval-resetter-2.1.6.zip">https://plugins.zhile.io/files/ide-eval-resetter-2.1.6.zip</a></p><p>2、安装插件直接下载插件 zip 包（macOS 可能会自动解压，然后把 zip 包丢进回收站）通常可以直接把 zip 包拖进 IDE 的窗口来进行插件的安装。如果无法拖动安装，你可以在Settings/Preferences… -&gt; Plugins 里手动安装插件（Install Plugin From Disk…）插件会提示安装成功</p><p>3、使用插件成功安装插件后，在 帮助 下会多一个 Eval Reset 按钮，如下图所示：</p><p><img src="https://laowangblog.com/wp-content/uploads/2020/11/jetbrains-%E8%AF%95%E7%94%A8.png"></p><p>一般来说，在 IDE 窗口切出去或切回来时（窗口失去/得到焦点）会触发事件，检测是否长时间（25 天）没有重置，给通知让你选择。（初次安装因为无法获取上次重置时间，会直接给予提示）也可以手动唤出插件的主界面：</p><ul><li><pre><code> 如果 IDE 没有打开项目，在Welcome界面点击菜单：Get Help -&gt; Eval Reset</code></pre></li><li><pre><code> 如果 IDE 打开了项目，点击菜单：Help -&gt; Eval Reset</code></pre></li></ul><p>唤出的插件主界面中包含了一些显示信息，2 个按钮，1 个勾选项：</p><ul><li>按钮：Reload 用来刷新界面上的显示信息。</li><li>按钮：Reset 点击会询问是否重置试用信息并重启 IDE。选择 Yes 则执行重置操作并重启 IDE 生效，选择 No 则什么也不做。（此为手动重置方式）</li><li>勾选项：Auto reset before per restart 如果勾选了，则自勾选后每次重启/退出 IDE 时会自动重置试用信息，你无需做额外的事情。（此为自动重置方式）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Eval Reset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sourcetree</title>
      <link href="2021/05/04/sourcetree/"/>
      <url>2021/05/04/sourcetree/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="sourcetree是免费的Git客户端，如何利用它从gitlab上拉取下代码呢？步骤如下："><a href="#sourcetree是免费的Git客户端，如何利用它从gitlab上拉取下代码呢？步骤如下：" class="headerlink" title="sourcetree是免费的Git客户端，如何利用它从gitlab上拉取下代码呢？步骤如下："></a>sourcetree是免费的Git客户端，如何利用它从gitlab上拉取下代码呢？步骤如下：</h1><ol><li><p>下载并安装git；</p></li><li><p>运行git,生成秘钥，</p><p> 在桌面右键打开Git bash Here输入命令为：ssh-keygen -t rsa<br>秘钥生成的目录在你系统盘用户目录下的.ssh\id_rsa.pub。(以前生成过，请删除在从新生成,避免错误)</p></li></ol><ol start="3"><li>在自己的git服务器上绑定自己git公钥;（绑定操作：Settings –&gt; SSH Keys –&gt; Add key（打开本地公钥文件粘贴里面所有内容））</li></ol><ol start="4"><li>利用sourcetree拉取代码。点击”工具–&gt;选项–&gt;一般”，注意以下4个部分的设置<ol><li>首先在选项里面填写拉去时所需信息，在一般和验证</li><li>填写完毕，点击文件clone（具体详细看图解）</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Jinkun123/blog_imgs/2020-01-12/Sourcetree.png"><br><img src="https://cdn.jsdelivr.net/gh/Jinkun123/blog_imgs/2020-01-12/Sourcetree2.png"><br><img src="https://cdn.jsdelivr.net/gh/Jinkun123/blog_imgs/2020-01-12/Sourcetree4.png"><br><img src="https://cdn.jsdelivr.net/gh/Jinkun123/blog_imgs/2020-01-12/Sourcetree3.png"></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/09/09/hello-world/"/>
      <url>2020/09/09/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 初始文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 默认 </tag>
            
            <tag> 初始 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
